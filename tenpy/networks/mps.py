"""This module contains a base class for a Matrix Product State (MPS)

It looks roughly like this:

     -- B[0] -- B[1] -- B[2] -- ...
        |       |       |

We use the following label convention (arrows indicate `qconj`)::

    vL ->- B ->- vR
           |
           ^
           p

.. todo ::

    - funktion getSite(), getsL etc!!
    - BC als Argument konsistent machen, was mit segment?!
    - wie man indizes zaehlt?
    - Funktion kanonisch
    - Check sanity implementieren
    - much much more ....
    - proper documentation
"""

from __future__ import division
import numpy as np
import itertools

from ..linalg import np_conserved as npc


class MPS(object):
    r""" A Matrix Product State (MPS) class that contains the sites (B) and bonds (s)

    We store in this MPS class the tensors corresponding to sites (labelled B),
    and the matrices corresponding to bonds (labelled s). Note that we have
    len(B)+1 entries for s, with the first corresponding to the bond to the left
    of the first site.

    We restrict ourselves to normalized states (i.e. ``np.linalg.norm(psi._S[ib]) == 1.``).

    For efficient simulations, it is crucial that the MPS is in a 'canonical form'.
    The different forms and boundary conditions are easiest described in Vidal's
    :math:`\Gamma, \Lambda` notation [1].

    Valid boundary conditions are the following:

    ==========  ===================================================================================
    `bc`        description
    ==========  ===================================================================================
    'finite'    Finite MPS, ``G0 s1 G1 ... s{L-1} G{l-1}``. This is acchieved
                by using a trivial left and right bond ``s[0] = s[-1] = np.array([1.])``.
    'segment'   Generalization of 'finite`, describes an MPS embedded in left and right
                environments. The left environment is described by ``chi[0]`` *orthonormal* states
                which are weighted by the singular values ``s[0]``. Similar, ``s[L]`` weight some
                right orthonormal states. You can think of the left and right states to be
                generated by additional MPS, such that the overall structure is something like
                ``... s L s L [s0 G0 s1 G1 ... s{L-1} G{L-1} s{L}] R s R s R ... ``
                (where we save the part in the brackets ``[ ... ]``).
    'infinite'  infinite MPS (iMPS): we save a 'MPS unit cell` ``[s0 G0 s1 G1 ... s{L-1} G{L-1}]``
                which is repeated periodically, identifying all indices modulo ``self.L``.
                In particular, the last bond ``L`` is identified with ``0`.
                (The MPS unit cell can differ from a lattice unit cell).
                bond is identified with the first one.
    ==========  ===================================================================================

    We store one 3-leg tensor `_Bs[i]` with labels ``'vL', 'vR', 'p'`` for each of the `L` sites
    ``0 <= i < L``.  Additionally, we store `L`+1 singular value arrays `s[ib]` on each bond
    ``0 <= ib <= L``. ``_Ss[ib]`` gives the singlur values on the bond ``i-1, i``.
    To take care of different canonical forms, algorithms should use functions like
    :meth:`get_theta` and :meth:`get_B` to access the Bs:
    these functions take care of various possible canonical forms.

    ==========  ===================================================================================
    `nu`        description
    ==========  ===================================================================================
    ``'B'``     right canonical: ``B[i] = -- Gamma[i] -- s[i+1]--``
                Algorithms are based on this form, so this form should be preferred to avoid
                problems
    ``'C'``     symmetric form: ``B[i] = -- s[i]**0.5 -- Gamma[i] -- s[i+1]**0.5--``
    ``'A'``     left canonical: ``B[i] = -- s[i] -- Gamma[i] --``.
                For stability reasons, we recommend not to use this form (because algorithms are
                based on the ``'B'`` form).
    ``None``    Non-canoncial form. No singular values are taken care of in :meth:`get_theta`
                and co. You should use :meth:`canoncial_from` (or similar) before using algorithms!
    ==========  ===================================================================================


    Parameters
    ----------
    arg : type
        TODO: document __init__ arguments here

    Attributes
    ----------
    L
    bond_inds
    chi
    sites : list of :class:`~tenpy.models.lattice.Site`
        Defines the local Hilbert space for each site.
    bc : {'finite', 'segment', 'infinite'}
        Boundary conditions as described in above table.
    form : None | (float, float)
        Describes the canonical form. ``None`` means non-canonical form, otherwise the stored
        `_Bs` are ``s**form[0] -- Gamma -- s**form[1]``.
        Can be compared to entries of `_valid_forms`
    dtype : type or string
        The data type of the `_Bs`.
    _B : list of :class:`npc.Array`
        The 'matrices' of the MPS. Labels are ``vL, vR, p`` (in any order).
        We recommend using :meth:`get_B` and :meth:`set_B`, which will take care of the different
        canonical forms.
    _S : list of 1D arrays
        The singular values on each virtual bond, length ``L+1``.
        ``_S[i]`` is to the left of ``_B[i]``.
        We recommend using :meth:`get_SL`, :meth:`get_SR`, :meth:`set_SL`, :meth:`set_SR`.
    _valid_forms : dict
        Mapping for canonical forms to a tuple ``(nuL, nuR)` such that
        ``self._Bs[i] = s[i]**nuL -- Gamma[i] -- s[i]**nuR`` can be saved.
    _valid_bc : tuple of str
        Valid boundary conditions.

    .. todo ::
        Write more documentation.

    References
    ----------
    [1] G. Vidal, Phys. Rev. Lett. 93, 040502 (2004), arXiv:quant-ph/0310089
    [2] U. Schollwoeck, Annals of Physics 326, 96 (2011), arXiv:1008.3477
    """

    #: Canonical form conventions: B = s**nu[0]--Gamma--s**nu[1].
    #: For canonical forms, ``nu[0] + nu[1] = 1``
    _valid_forms = {
        'A': (1., 0.),
        'C': (0.5, 0.5),
        'B': (0., 1.),
        None: (0., 0.),  # not in any canonical form
    }

    #: valid boundary conditions. Don't overwrite this!
    _valid_bc = ('finite', 'segment', 'infinite')

    def __init__(self, sites, Bs, SVs, bc='finite', form='B'):
        self.sites = list(sites)
        self.chinfo = self.sites[0].leg.chinfo
        self.dtype = dtype = Bs[0].dtype

        # make copies of Bs and SVs
        self._B = [B.astype(dtype, copy=True) for B in Bs]
        self._S = [np.array(s, dtype=np.float) for s in SVs]
        self.form = self._valid_forms[form]  # tuple (nuL, nuR) describing canonical form.
        self.bc = bc  # one of ``'finite', 'periodic', 'segment'``.

        # TODO: We so far don't include the old grouped,can_keep
        # JH: we don't need 'grouped', that's what `Lattice` and `Site` are for.
        #     `can_keep` should be an argument of `canonical_form2`.

        self.check_sanity()

    def check_sanity(self):
        """Sanity check. Raises Errors if something is wrong."""
        if self.bc not in self._valid_bc:
            raise ValueError("invalid boundary condition: " + repr(self.bc))
        # TODO: much more checks

    @classmethod
    def from_product_state(cls,
                           sites,
                           p_state,
                           bc='finite',
                           dtype=np.float,
                           form='B',
                           chargeL=None):
        """ Construct a matrix product state from a given product state.

        Parameters
        ----------
        sites : list of :class:`~tenpy.networks.site.Site`
            The sites defining the local Hilbert space.
        p_state : iterable of {int | 1D array}
            Defines the product state.
            If ``p_state[i]`` is int, then site ``i`` is in state ``p_state[i]``
            If ``p_state[i]`` is an array, then site ``i``s wavefunction is ``p_state[i]``
        bc : {'infinite', 'finite', 'segmemt'}
            MPS boundary conditions. See docstring of :class:`MPS`.
        dtype : type or string
            The data type of the array entries.
        form : None | str
            defines the canonical form. See docstring of :class:`MPS`.
        chargeL: charges
            Bond charges at bond 0, which are(purely conventional) #Do we need this??

        """
        sites = list(sites)
        L = len(sites)
        p_state = list(p_state)
        if len(p_state) != L:
            raise ValueError("Length of p_state does not match number of sites.")
        ci = sites[0].leg.chinfo
        Bs = []
        chargeL = ci.make_valid(chargeL)  # sets to zero if `None`
        legL = npc.LegCharge.from_qflat(ci, chargeL)

        for i, site in enumerate(sites):
            try:
                iter(p_state[i])
                if len(p_state[i]) != site.dim:
                    raise ValueError("p_state incompatible with local dim:" + repr(p_state[i]))
                B = np.array(p_state[i], dtype).reshape((site.dim, 1, 1))
            except TypeError:
                B = np.zeros((site.dim, 1, 1), dtype)
                B[p_state[i], 0, 0] = 1.0
            # calculate the LegCharge of the right leg
            legs = [site.leg, legL, None]  # other legs are known
            legs = npc.detect_legcharge(B, ci, legs, None, qconj=-1)
            B = npc.Array.from_ndarray(B, ci, legs, dtype)
            B.set_leg_labels(['p', 'vL', 'vR'])
            Bs.append(B)
            legL = legs[-1].conj()  # prepare for next `i`
        if bc == 'infinite':
            # for an iMPS, the last leg has to match the first one.
            # so we need to gauge `qtotal` of the last `B` such that the right leg matches.
            chdiff = Bs[-1].get_leg('vR').charges[0] - Bs[0].get_leg('vL').charges[0]
            Bs[-1] = Bs[-1].gauge_qtotal('vR', ci.make_valid(chdiff))
        SVs = [[1.]] * (L + 1)
        return cls(sites, Bs, SVs, form=form, bc=bc)

    @property
    def L(self):
        """Number of physical sites. For an iMPS the len of the MPS unit cell."""
        return len(self.sites)

    @property
    def dim(self):
        """List of local physical dimensions."""
        return [site.dim for site in self.sites]

    @property
    def finite(self):
        "Distinguish MPS (``True; bc='finite', 'segment'`` ) vs. iMPS (``False; bc='infinite'``)"
        assert (self.bc in self._valid_bc)
        return self.bc != 'inifinite'

    @property
    def chi(self):
        """Dimensions of the virtual bonds"""
        # TODO: for a finitie MPS only on the non-trivial bonds?
        return [len(s) for s in self._S]

    def _to_valid_index(self, i):
        if not self.finite:
            return i % self.L
        if i < 0:
            i += self.L
        if i >= self.L or i < 0:
            raise ValueError, "i = %s out of bounds for finite MPS" % i
        return i

    def get_B(self, i, form='B', copy=False):
        """return `B` in canonical form at site `i`.

        .. todo ::
            take care of `form`!!!
        """
        i = self._to_valid_index(i)
        if copy:
            return self._B[i].copy(deep=True)
        else:
            return self._B[i]

    def set_B(self, i, B, form='B'):
        """set `B` at site `i`. The given `B` is in canonical form described by `form`."""
        i = self._to_valid_index(i)
        if self._valid_forms[form] != self.form:
            # TODO: what if form is different???
            raise NotImplementedError()
        self._B[i] = B

    def get_SL(self, i):
        """return singular values on the left of site `i`"""
        i = self._to_valid_index(i)
        return self._S[i]

    def get_SR(self, i):
        """set singular values on the right of site `i`"""
        i = self._to_valid_index(i)
        return self._S[(i + 1)]

    def set_SL(self, i, S):
        """set singular values on the left of site `i`"""
        i = self._to_valid_index(i)
        self._S[i] = S

    def set_SR(self, i, S):
        """set singular values on the left of site `i`"""
        i = self._to_valid_index(i)
        self._S[(i + 1)] = S

    def get_theta(self,i,n = 2):
        """ Returns the n-site wavefunction
            th = s G_i1 s G_i2 . . . G_in s.
            If n != 1, we will stick to the convention of
            calling the physical labels p0, p1, ....
            If n = 1, we will label the physical leg p in order
            to be consistent with the B notation.
        """
        i = self._to_valid_index(i)
        if self.finite:
            if (i < 0 or i + n > self.L): raise ValueError, "i = %s out of bounds" % i

        fL = 1 - self.form[0] #left factor
        fR = 1 - self.form[1] #right factor
        theta = self.get_B(i,copy = True)
        sL = self.get_SL(i)
        theta.iscale_axis(sL**fL,axis = 'vL')

        if n == 1:
            sR = self.get_SR(i)
            return theta.iscale_axis(sR**fR, axis = 'vR')

        theta.ireplace_label('p','p0')
        sofar = 1
        for i in range(i+1,i + n):
            B = self.get_B(i,copy=True)
            #TODO: MS to JH, not sure, you know more about this copy stuff
            B.ireplace_label('p','p'+str(sofar))
            if sofar == n-1:
                sR = self.get_SR(i)
                B = B.scale_axis(sR**fR, axis = 'vR' )
            theta = npc.tensordot(theta, B, axes=('vR', 'vL'))
            sofar+=1
        return theta
